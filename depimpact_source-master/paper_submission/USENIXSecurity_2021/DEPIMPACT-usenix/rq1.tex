\input{tables/2021usenix/rq1.tex}



\subsection{RQ1: Revealing Attack Sequences}
\label{subsec:rq1}
To demonstrate the effectiveness of \tool in revealing the attack sequence by pruning non-critical edges, we compare \tool with 4 state-of-the-art techniques: CPR~\cite{reduction}, ReadOnly~\cite{loggc}, PrioTracker~\cite{liu2018priotracker}, and NoDoze~\cite{hassan2019nodoze}. 
%As discussed in \cref{subsubsec:entry-ranking},
\tool uses 6 entry nodes, composed of the top 2 entry nodes from the 3 types of system entities (\ie files, processes, and network connections), to perform forward causality analysis, which is shown to preserve all the critical edges (see \cref{subsec:rq2}).
For the attacks involving multiple POI events, we applied \tool on each of the POI events and then union the generated critical components. 
CPR merges edges between two nodes if the time differences between the edges are within a threshold (\ie 10 seconds).
ReadOnly removes the edge whose source node is the read-only file. 
PrioTracker mainly uses the fanout of nodes to prioritize the dependencies in the causality analysis. 
We then adapt the computed priories as the dependency weights for edges and filter the edges with low weights.
%for comparison with \tool. 
NoDoze assigns an anomaly score for each edge based on the frequency of the corresponding system event, and then computes the anomaly score for each path. 
% Paths having higher anomaly scores will be reported. 
As NoDoze requires an execute profile, we use the daily log file of the deployed system as the execution profile for the attacks in our deployed hosts,
and use the normal events in the logs (except the events whose observed time are within the attack period) for the attacks in the DARPA TC dataset.
Based on the ground truth of each attack, we manually assign lower reputation scores for the malicious files and IP addresses as required by NoDoze.
Once NoDoze finishes computing the anomaly scores for the whole graph, we perform the graph reduction based on the anomaly score of each path in the dependency graph. 
% Note that it is fairly easy for a technique to keep all the critical edges by keeping all the edges generated by the causality analysis from the POI event, but it is far more difficult to preserve the critical edges and filter the non-critical edges at the same time. 
% Thus, we tune the parameters of all the techniques to preserve all the critical edges whenever possible, and compare the results of dependency graph reduction in terms of the number of edges.

\cref{tab:rq1} shows the dependency graph reduction of \tool and the other techniques.
The results show that \tool achieves the best performance for dependency graph reduction. 
On average, the size of the dependency graph generated by \tool (\ie the critical component output by \tool) is \emph{at least $106\times$ smaller than the second-best result} (\ie NoDoze) and three or four orders of magnitudes smaller than the other 3 techniques.
We next explain the comparison with each technique.

CPR merges only the edges between pairs of nodes, and thus lack the capabilities to prune irrelevant edges originated from irrelevant system activities.
% the results demonstrate the better pruning power brought by the forward causality analysis from the top-ranked entry nodes.
Removing read-only files is heuristics-based and cannot robustly achieve good performance for different attacks as illustrated by the results (\eg $58$ for the ``Wget executable'' attack v.s. $600,000+$ for the ``Hide File'' attack).
%pure data amount 
% We also try another similar heuristic-based technique that only keeps edges has similar data amount as the POI. But this technique cannot work well for the case whose dependency graph is large. 
% Because for a large dependency graph, many edges have similar data amount, the technique that depends on the simple heuristic rule usually cannot work robustly for real complex attacks.   
The comparison with PrioTracker shows the superiority of our \textit{discriminative feature projection scheme} over the fanout feature in PrioTracker.
From the results, we can observe that NoDoze  performs generally well but poorly for certain attacks (\eg producing graphs with $>10,000$ edges for 5 attacks)
% , \eg the ``Hide File'' attack, the ``Steal information'' attack, and ``Theia Case1'' whose dependency graphs have more than millions of edges. 
The major reason is that there are many rare benign events in these dependency graphs that do not appear in the execution profiles.
% In NoDoze, the anomaly score of a given path is the product of each event's probability along the path. 
% These rare benign events cause many paths that include these benign events to have higher anomaly scores, which greatly degrades the effectiveness of NoDoze.
In other words, the effectiveness of NoDoze heavily relies on whether the execution profile can capture all the benign events, which is generally difficult since the runtime environment of most organizations are dynamic and versatile.
%
On the other hand, compared to NoDoze, \tool achieves better reduction results without sharing its two major limitations:
(1) \tool does not rely on third-party services to assign reputations to malicious files or IP addresses, which may introduce additional risks and complexity;
(2) \tool does not require the execution profile of the deployed system for training. 
These characteristics greatly reduce the difficulty of deploying \tool in a new system, enabling \tool to achieve better generalization than NoDoze.

\begin{figure}[t]
    \centering
    \includegraphics[width=0.47\textwidth]{figs/2021usenix/darpa.pdf}
    \caption{Critical component generated by \tool for the ``Theia Case 1'' attack}
    \label{fig:darpa}
\end{figure} 
\begin{figure*}[t]
    \centering
    \includegraphics[width=0.9\textwidth, clip]{figs/2021usenix/multihost.pdf}
    \caption{Critical components generated by \tool for the ``Shellshock'' attack (non-critical edges are omitted). \tool generates critical components for the three POI events and takes the union of the generated critical components, which covers all the attack steps as described in \cref{subsubsec:attack-cases}.}
    \label{fig:multi}
\end{figure*}

\myparatight{Case Study}
\cref{fig:darpa,fig:multi} show the critical components of two attacks. 
We use solid lines to represent critical edges, dash lines to represent non-critical edges, and dot-and-dash lines to label attack entries. 
POI events are clearly marked with text descriptions.
% For the POI of the attack, we label the node with text (\ie POI).

\cref{fig:darpa} shows the
%dependency graph 
critical component generated by \tool for the ``Theia Case 1'' attack in the DARPA TC dataset. 
We can observe that the firefox browser is started to download the file \incode{/home/admin/clean} from a malicious IP address.
% which is a backdoor-download behavior. 
Here, the IP addresses (\ie the source of the backdoor) are correctly identified as attack entries, and all the critical edges are preserved.
% The attack entries are the IP addresses, the source of the backdoor.
% The POI is the downloaded file. 
% For this attack, the attack sequence consists of 8 edges and \tool generates a graph of 62 edges that preserves all the 8 edges, while the other state-of-art techniques keep hundreds of thousands of edges, demonstrating the superiority of \tool.



%  POI-I and then get the first critical component, which reflects the attacker downloaded the malicious script and then sent it to other hosts through scp. \tool investigates POI-II and then get the second critical component, which shows the attacker executed the malicious script to collect user sensitive data and then sent it back to first victim. \tool investigates POI-III and then get the third critical component, which reflects the attacker compressed these sensitive data and sent it back to the C2 server.

\cref{fig:multi} shows the 3 critical components generated by \tool for the ``Shellshock'' attack. 
The critical component of POI I (step \ding{172}) shows that Host 1 first downloads a malicious script from the C2 server, and then sends a malicious script \incode{/tmp/crack_password.sh} to Host 2 through the process \incode{scp}. 
% Here, the attack entry is the network connection with the C2 server and the POI is the network connection with Host 2 (\ie POI I). 
Then, this malware collects user sensitive data in Host 2 and sends this data back to Host 1 through the process \incode{scp} (step \ding{173}). 
% For this series of behaviors, the attack entry is the POI-I and the POI is the lateral network connection with Host 1 (\ie POI II).  
After this step, the sensitive data is compressed in Host 1 and sent back to the C2 server (\ding{174}). 
% For this series of behaviors, the attack entry POI-II and the POI is the compressed file (\ie POI III), which contains user's sensitive data. 
For this graph, the union of the 3 critical components in 2 hosts covers all the critical edges.
In particular, the two special network connection edges in steps \ding{172} and \ding{173} enable the cross-host dependency tracking for revealing attack sequences.



  